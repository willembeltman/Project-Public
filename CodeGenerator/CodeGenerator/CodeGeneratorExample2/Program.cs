using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Reflection;

namespace CodeGeneratorExample2;

internal class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Starting runtime code generation demo...\n");

        var instance = InstanceFactory.CreateInstance("Hello, World!");
        instance.SayHello("Willem");
    }
}

public class Instance
{
    public Instance(Action<string> sayHelloDelegate)
    {
        SayHelloDelegate = sayHelloDelegate;
    }

    public Action<string> SayHelloDelegate { get; }
    public void SayHello(string name) => SayHelloDelegate(name);
}

public static class InstanceFactory
{
    public static Instance CreateInstance(string greeting)
    {
        // Gebruik reflection voor een klein stukje metadata
        var assembly = Assembly.GetExecutingAssembly();
        var classNames = assembly.GetTypes().Select(t => t.Name);
        var joinedNames = string.Join(", ", classNames);

        // Dynamisch te genereren class + methode
        const string className = "HelloWorld";
        const string methodName = "SayHello";

        var code = $@"// <auto-generated />
using System;

public class {className}
{{
    public static void {methodName}(string name)
    {{
        Console.WriteLine($""{greeting} {{name}}! From reflection we found: {joinedNames}"");
    }}
}}";

        try
        {
            // Parse en compileer dynamisch
            var syntaxTree = CSharpSyntaxTree.ParseText(code);

            var references = AppDomain.CurrentDomain.GetAssemblies()
                .Where(a => !a.IsDynamic && !string.IsNullOrEmpty(a.Location))
                .Select(a => MetadataReference.CreateFromFile(a.Location))
                .ToList();

            var compilation = CSharpCompilation.Create(
                assemblyName: "GeneratedCodeLibrary",
                syntaxTrees: new[] { syntaxTree },
                references: references,
                options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
            );

            using var ms = new MemoryStream();
            var result = compilation.Emit(ms);

            if (!result.Success)
            {
                var errors = string.Join("\n", result.Diagnostics
                    .Where(d => d.Severity == DiagnosticSeverity.Error)
                    .Select(d => d.ToString()));
                throw new InvalidOperationException($"Compile error:\n{errors}");
            }

            // Laad de gegenereerde assembly in memory
            ms.Seek(0, SeekOrigin.Begin);
            var asm = Assembly.Load(ms.ToArray());

            // Zoek class + methode
            var type = asm.GetType(className)
                ?? throw new InvalidOperationException($"Cannot find generated class '{className}'.");
            var method = type.GetMethod(methodName, BindingFlags.Public | BindingFlags.Static)
                ?? throw new InvalidOperationException($"Cannot find generated method '{methodName}'.");

            // Maak een delegate aan en koppel die aan een Instance
            var sayHelloDelegate = (Action<string>)Delegate.CreateDelegate(typeof(Action<string>), method);
            return new Instance(sayHelloDelegate);
        }
        catch (Exception ex)
        {
            throw new Exception(
                $"❌ Exception while compiling dynamic code.\nGenerated code:\n\n{code}\n\nError details:\n{ex}",
                ex);
        }
    }
}
